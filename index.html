<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5.0,user-scalable=yes" />
<title>粗大ごみ寸法判定ツール（完全オフセット対応）</title>
<style>
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Noto Sans JP", sans-serif;
    line-height: 1.6;
    margin: 0;
    background-color: #fff;
    -webkit-user-select: none;
    user-select: none;
  }
  #mainWrapper { padding: 16px; padding-bottom: 40px; }
  h1{ font-size:1.25rem; margin:0 0 8px; }
  .panel{ border:1px solid #ddd; border-radius:8px; padding:12px; margin-bottom:16px; background: #fff; }
  .row{ display:flex; flex-direction: column; gap:12px; }
  .col{ flex:1 1 320px; }
  canvas{
    width:100%; height:auto; max-width:100%;
    border:1px dashed #bbb; border-radius:6px; background:#f8f8f8;
    touch-action:none; 
  }
  button,input[type="file"]{ padding:8px 12px; font-size:14px; margin:2px 4px 2px 0; touch-action: manipulation; }
  .btn-row{ margin:4px 0; display:flex; flex-wrap:wrap; gap:4px; }
  .muted{ color:#666; font-size:0.9em; }
  .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; margin-left:6px; font-size:0.8em; }
  .result{ font-size:1.0rem; padding:4px 0; font-weight:bold; color:#0056b3; }
  .small{ font-size:0.85em; color:#555; }
  .grid{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
  @media (max-width:900px){ .grid{ grid-template-columns:1fr; } }
</style>
</head>
<body>

<div id="mainWrapper">
  <h1>粗大ごみ寸法判定ツール（完全オフセット対応）</h1>
  <p class="muted">
    <b>使い方：</b>スケール指定も、四角形の指定も、<b>指の少し上（約1.5cm上）</b>が操作位置になります。指で隠れずに精密な指定が可能です。
  </p>

  <div class="grid">
    <div class="panel">
      <h2>① 上からの写真（W＋D）<span class="pill">top</span></h2>
      <input type="file" id="topFile" accept="image/*" />
      <div class="btn-row">
        <button id="topScale">スケール指定 (指オフセット)</button>
        <button id="topAuto">自動抽出</button>
        <button id="topManual">手動矩形 (指オフセット)</button>
      </div>
      <div class="row">
        <div class="col">
          <canvas id="topCanvas" width="640" height="480"></canvas>
          <div class="small" id="topMsg">画像を選択してください</div>
        </div>
        <div class="col">
          <div class="result" id="topInfo">W=? / D=?</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>② 横からの写真（H）<span class="pill">side</span></h2>
      <input type="file" id="sideFile" accept="image/*" />
      <div class="btn-row">
        <button id="sideScale">スケール指定 (指オフセット)</button>
        <button id="sideAuto">自動抽出</button>
        <button id="sideManual">手動矩形 (指オフセット)</button>
      </div>
      <div class="row">
        <div class="col">
          <canvas id="sideCanvas" width="640" height="480"></canvas>
          <div class="small" id="sideMsg">画像を選択してください</div>
        </div>
        <div class="col">
          <div class="result" id="sideInfo">H=?</div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel">
    <h2>③ 結果判定</h2>
    <div id="summary" class="result">未計算</div>
  </div>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="console.log('OpenCV loaded')"></script>
<script>
var REAL_LEN_MM = 100; // 100mm基準
function $(id){ return document.getElementById(id); }

// 状態管理
var S = {
  top:  { bg:null, mode:"idle", clicks:[], rect:null, scale:null, W:null, D:null, scalePoints:[], aimingCursor:null },
  side: { bg:null, mode:"idle", clicks:[], rect:null, scale:null, H:null, scalePoints:[], aimingCursor:null }
};

// --- Canvas基本処理 ---
function loadToCanvas(file, canvasId, kind){
  if(!file) return;
  var canvas = $(canvasId);
  var ctx = canvas.getContext("2d");
  var img = new Image();
  img.onload = function(){
    var maxW = 800, maxH = 800;
    var w = img.naturalWidth, h = img.naturalHeight;
    var s = Math.min(maxW/w, maxH/h);
    canvas.width = Math.round(w*s);
    canvas.height = Math.round(h*s);
    
    ctx.drawImage(img,0,0,canvas.width,canvas.height);
    S[kind].bg = ctx.getImageData(0,0,canvas.width,canvas.height);
    
    // リセット
    S[kind].mode = "idle";
    S[kind].clicks = [];
    S[kind].rect = null;
    S[kind].scale = null;
    S[kind].scalePoints = [];
    S[kind].aimingCursor = null;
    
    $(kind+"Msg").innerHTML = "モードを選んで操作してください";
    drawOverlay(kind);
  };
  var reader = new FileReader();
  reader.onload = function(e){ img.src = e.target.result; };
  reader.readAsDataURL(file);
}

// 描画ループ
function drawOverlay(kind){
  var canvas = $(kind+"Canvas");
  var ctx = canvas.getContext("2d");
  var st = S[kind];
  
  if(st.bg) ctx.putImageData(st.bg,0,0);
  else ctx.clearRect(0,0,canvas.width,canvas.height);

  // 確定済みの青点
  var points = (st.mode==="scale" && st.clicks.length>0) ? st.clicks : st.scalePoints;
  if(points){
    ctx.lineWidth=2;
    for(var i=0; i<points.length; i++){
      var p = points[i];
      ctx.fillStyle="#2b74ff";
      ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="#fff"; ctx.strokeStyle="#000"; ctx.font="bold 14px sans-serif";
      ctx.strokeText(i+1, p.x+8, p.y-8);
      ctx.fillText(i+1, p.x+8, p.y-8);
    }
    if(points.length===2){
      ctx.strokeStyle="#2b74ff";
      ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); ctx.lineTo(points[1].x, points[1].y); ctx.stroke();
    }
  }

  // ドラッグ中の「照準カーソル」（スケールモード時のみ表示）
  if(st.aimingCursor && st.mode === "scale"){
    var cx = st.aimingCursor.x;
    var cy = st.aimingCursor.y;
    ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx - 20, cy); ctx.lineTo(cx + 20, cy);
    ctx.moveTo(cx, cy - 20); ctx.lineTo(cx, cy + 20);
    ctx.stroke();
    ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = "#ff00ff"; ctx.beginPath(); ctx.arc(cx, cy, 2, 0, Math.PI*2); ctx.fill();
  }

  // 矩形
  if(st.rect){
    ctx.strokeStyle="#ff3b30"; ctx.lineWidth=3;
    ctx.strokeRect(st.rect.x, st.rect.y, st.rect.w, st.rect.h);
  }
}

// 座標取得 (オフセット機能付き)
function getCanvasPoint(ev, canvas, isOffset){
  var rect = canvas.getBoundingClientRect();
  var clientX, clientY;
  
  if(ev.touches && ev.touches.length>0){
    clientX = ev.touches[0].clientX;
    clientY = ev.touches[0].clientY;
  } else if(ev.changedTouches && ev.changedTouches.length>0){
    clientX = ev.changedTouches[0].clientX;
    clientY = ev.changedTouches[0].clientY;
  } else {
    clientX = ev.clientX;
    clientY = ev.clientY;
  }

  // ★指のY座標をずらす（矩形モードでも有効になります）
  if(isOffset){
    clientY = clientY - 60; 
  }

  var scaleX = canvas.width / rect.width;
  var scaleY = canvas.height / rect.height;

  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

// イベント設定
function setupCanvasEvents(kind){
  var canvas = $(kind+"Canvas");
  var st = S[kind];
  var isDragging = false;
  var dragStart = null; 

  // --- タッチ操作 (スマホ) ---
  
  canvas.addEventListener("touchstart", function(ev){
    ev.preventDefault();
    if(st.mode === "scale"){
      // スケールモード：オフセット有効(true)
      st.aimingCursor = getCanvasPoint(ev, canvas, true); 
      drawOverlay(kind);
    } else if(st.mode === "manual"){
      isDragging = true;
      // ★矩形モード：ここを true (オフセット有効) に変更しました
      dragStart = getCanvasPoint(ev, canvas, true);
    }
  }, {passive:false});

  canvas.addEventListener("touchmove", function(ev){
    ev.preventDefault();
    if(st.mode === "scale"){
      st.aimingCursor = getCanvasPoint(ev, canvas, true);
      drawOverlay(kind);
    } else if(st.mode === "manual" && isDragging){
      // ★矩形モード：ここも true (オフセット有効) に変更しました
      var cur = getCanvasPoint(ev, canvas, true);
      st.rect = {
        x: Math.min(dragStart.x, cur.x), y: Math.min(dragStart.y, cur.y),
        w: Math.abs(dragStart.x - cur.x), h: Math.abs(dragStart.y - cur.y)
      };
      drawOverlay(kind);
    }
  }, {passive:false});

  canvas.addEventListener("touchend", function(ev){
    ev.preventDefault();
    if(st.mode === "scale" && st.aimingCursor){
      st.clicks.push(st.aimingCursor);
      st.aimingCursor = null; 
      if(st.clicks.length > 2) st.clicks.shift();
      drawOverlay(kind);
      if(st.clicks.length === 2) commitScale(kind);
      
    } else if(st.mode === "manual" && isDragging){
      isDragging = false;
      applyManualRect(kind);
      drawOverlay(kind);
    }
  }, {passive:false});

  // --- マウス操作 (PC) ---
  // PCはカーソルが見えるのでオフセットなし(false)のままにします
  
  canvas.addEventListener("mousedown", function(ev){
    if(st.mode === "scale"){
      var p = getCanvasPoint(ev, canvas, false);
      st.clicks.push(p);
      if(st.clicks.length > 2) st.clicks.shift();
      drawOverlay(kind);
      if(st.clicks.length === 2) commitScale(kind);
    } else if(st.mode === "manual"){
      isDragging = true;
      dragStart = getCanvasPoint(ev, canvas, false);
    }
  });
  
  canvas.addEventListener("mousemove", function(ev){
    if(st.mode==="manual" && isDragging){
      var cur = getCanvasPoint(ev, canvas, false);
      st.rect = {
        x: Math.min(dragStart.x, cur.x), y: Math.min(dragStart.y, cur.y),
        w: Math.abs(dragStart.x - cur.x), h: Math.abs(dragStart.y - cur.y)
      };
      drawOverlay(kind);
    }
  });

  canvas.addEventListener("mouseup", function(){
    if(st.mode==="manual" && isDragging){
      isDragging = false; applyManualRect(kind); drawOverlay(kind);
    }
  });
}

// 処理ロジック
function commitScale(kind){
  var st = S[kind];
  var a = st.clicks[0], b = st.clicks[1];
  var dist = Math.sqrt(Math.pow(a.x-b.x,2)+Math.pow(a.y-b.y,2));
  if(dist < 5){ alert("点が近すぎます"); st.clicks=[]; drawOverlay(kind); return; }
  
  st.scale = REAL_LEN_MM / dist;
  st.scalePoints = [a, b];
  st.clicks = [];
  st.mode = "idle";
  $(kind+"Msg").innerHTML = "スケール設定完了。次に「自動抽出」か「矩形」を行ってください。";
  drawOverlay(kind);
  updateInfo(kind);
}

function applyManualRect(kind){
  var st = S[kind];
  if(!st.rect || !st.scale) return;
  if(kind==="top"){ st.W = st.rect.w * st.scale; st.D = st.rect.h * st.scale; }
  else { st.H = st.rect.h * st.scale; }
  updateInfo(kind);
}

function autoExtract(kind){
  var st = S[kind];
  if(!st.scale){ alert("先にスケール指定をしてください"); return; }
  if(!st.bg){ alert("画像がありません"); return; }
  
  var canvas = $(kind+"Canvas");
  var src = cv.matFromImageData(st.bg);
  var gray = new cv.Mat(), blur = new cv.Mat(), thr = new cv.Mat();
  
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
  cv.adaptiveThreshold(blur, thr, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
  
  var contours = new cv.MatVector();
  var hierarchy = new cv.Mat();
  cv.findContours(thr, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  
  var maxArea=0, maxRect=null;
  for(var i=0; i<contours.size(); i++){
    var cnt = contours.get(i);
    var area = cv.contourArea(cnt);
    if(area > maxArea){
      maxArea = area;
      maxRect = cv.boundingRect(cnt);
    }
  }
  
  if(maxRect && maxArea > 1000){
    st.rect = { x:maxRect.x, y:maxRect.y, w:maxRect.width, h:maxRect.height };
    applyManualRect(kind);
    drawOverlay(kind);
  } else {
    alert("物体を自動検出できませんでした。手動で矩形を描いてください。");
  }
  
  src.delete(); gray.delete(); blur.delete(); thr.delete(); contours.delete(); hierarchy.delete();
}

function updateInfo(kind){
  var st = S[kind];
  var el = $(kind+"Info");
  if(kind==="top") el.textContent = "W="+(st.W?st.W.toFixed(0):"?")+" / D="+(st.D?st.D.toFixed(0):"?")+" mm";
  else el.textContent = "H="+(st.H?st.H.toFixed(0):"?")+" mm";
  
  var W=S.top.W||0, D=S.top.D||0, H=S.side.H||0;
  if(W&&D&&H){
    var sum = W+D+H;
    var cls = sum<1500?1 : sum<2000?2 : sum<2500?3 : 4;
    $("summary").innerHTML = "合計: "+sum.toFixed(0)+" mm<br>区分: <span style='font-size:1.5em;color:red'>"+cls+"</span>";
  }
}

// 初期化
window.onload = function(){
  $("topFile").onchange = function(e){ loadToCanvas(e.target.files[0], "topCanvas", "top"); };
  $("sideFile").onchange = function(e){ loadToCanvas(e.target.files[0], "sideCanvas", "side"); };
  
  $("topScale").onclick = function(){ S.top.mode="scale"; S.top.clicks=[]; S.top.scalePoints=[]; $("topMsg").innerText="10cm定規の両端をなぞって指定してください"; drawOverlay("top"); };
  $("sideScale").onclick = function(){ S.side.mode="scale"; S.side.clicks=[]; S.side.scalePoints=[]; $("sideMsg").innerText="10cm定規の両端をなぞって指定してください"; drawOverlay("side"); };
  
  $("topManual").onclick = function(){ S.top.mode="manual"; S.top.rect=null; $("topMsg").innerText="物体をドラッグして囲んでください"; drawOverlay("top"); };
  $("sideManual").onclick = function(){ S.side.mode="manual"; S.side.rect=null; $("sideMsg").innerText="物体をドラッグして囲んでください"; drawOverlay("side"); };
  
  $("topAuto").onclick = function(){ autoExtract("top"); };
  $("sideAuto").onclick = function(){ autoExtract("side"); };
  
  setupCanvasEvents("top");
  setupCanvasEvents("side");
};
</script>
</body>
</html>
